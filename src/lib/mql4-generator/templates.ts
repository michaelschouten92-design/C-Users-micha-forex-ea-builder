// MQL4 Code Templates

import type { GeneratorContext, OptimizableInput } from "./types";
import { sanitizeMQL4String } from "./generators/shared";

export function generateFileHeader(ctx: GeneratorContext): string {
  const timestamp = new Date().toISOString();
  const desc = ctx.description ? sanitizeMQL4String(ctx.description) : "";
  // Sanitize project name for comment lines (strip characters that could break MQL comment syntax)
  const safeName = ctx.projectName.replace(/[^\w\s\-.]/g, "").substring(0, 36);
  const descLines = desc
    ? desc
        .split(/\\n|\n/)
        .filter((l: string) => l.trim())
        .map((l: string) => `#property description "${l.substring(0, 511)}"`)
        .join("\n")
    : `#property description "${safeName} — Generated by AlgoStudio"`;
  return `//+------------------------------------------------------------------+
//|                                    ${safeName.padEnd(36)}|
//|                                    Generated by AlgoStudio        |
//|                                    ${timestamp.substring(0, 19).padEnd(36)}|
//+------------------------------------------------------------------+
#property copyright "AlgoStudio"
#property link      "https://algo-studio.com"
#property version   "1.00"
#property strict
${descLines}

`;
}

export function generateTradeIncludes(): string {
  // MQL4 does not need trade includes — OrderSend/OrderClose are built-in
  return `//--- MQL4: No trade library needed (OrderSend/OrderClose are built-in)

`;
}

export function generateInputsSection(inputs: OptimizableInput[]): string {
  if (inputs.length === 0) return "";

  const lines: string[] = [];
  let currentGroup = "";

  // Emit custom timeframe enum if any timeframe inputs exist
  const hasTimeframeInputs = inputs.some((i) => i.type === "ENUM_AS_TIMEFRAMES");
  if (hasTimeframeInputs) {
    lines.push("//--- Timeframes (only AlgoStudio-supported timeframes for optimization)");
    lines.push("enum ENUM_AS_TIMEFRAMES");
    lines.push("{");
    lines.push("   TF_M1  = PERIOD_M1,   // M1");
    lines.push("   TF_M5  = PERIOD_M5,   // M5");
    lines.push("   TF_M15 = PERIOD_M15,  // M15");
    lines.push("   TF_M30 = PERIOD_M30,  // M30");
    lines.push("   TF_H1  = PERIOD_H1,   // H1");
    lines.push("   TF_H4  = PERIOD_H4,   // H4");
    lines.push("   TF_D1  = PERIOD_D1,   // D1");
    lines.push("   TF_W1  = PERIOD_W1,   // W1");
    lines.push("   TF_MN1 = PERIOD_MN1   // MN1");
    lines.push("};");
    lines.push("");
  }

  for (const input of inputs) {
    // Add group header when group changes
    if (input.group && input.group !== currentGroup) {
      currentGroup = input.group;
      if (lines.length > 0) lines.push("");
      lines.push(`//--- ${currentGroup}`);
    }

    // MQL4 has no sinput keyword — use input for all visible, const for hidden
    if (input.isOptimizable) {
      lines.push(`input ${input.type} ${input.name} = ${input.value}; // ${input.comment}`);
    } else if (input.alwaysVisible) {
      // MQL4: no sinput — use input with comment noting it's not optimizable
      lines.push(
        `input ${input.type} ${input.name} = ${input.value}; // ${input.comment} (not optimizable)`
      );
    } else {
      lines.push(`const ${input.type} ${input.name} = ${input.value}; // ${input.comment}`);
    }
  }

  return `//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
${lines.join("\n")}

`;
}

export function generateGlobalVariablesSection(variables: string[]): string {
  if (variables.length === 0) return "";

  return `//+------------------------------------------------------------------+
//| Global Variables                                                   |
//+------------------------------------------------------------------+
${variables.join("\n")}

`;
}

export function generateOnInit(ctx: GeneratorContext, initCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Validate trading is allowed
   if(!IsTradeAllowed())
   {
      Print("Trading is not allowed for this account/symbol");
      return(INIT_FAILED);
   }

${initCode.map((line) => "   " + line).join("\n")}

   //--- Display strategy info on chart
   ShowStrategyOverlay();

   Print("${ctx.projectName} initialized successfully on ", Symbol(), " ", EnumToString((ENUM_TIMEFRAMES)Period()));
   return(INIT_SUCCEEDED);
}

`;
}

export function generateOnDeinit(deinitCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
${deinitCode.length > 0 ? deinitCode.map((line) => "   " + line).join("\n") : "   //--- No cleanup needed"}

   //--- Remove strategy overlay from chart
   ObjectsDeleteAll(0, "AS_Info_");
   Comment("");

   //--- Log deinitialization reason
   string reasonText;
   switch(reason)
   {
      case REASON_PROGRAM:     reasonText = "EA stopped by user"; break;
      case REASON_REMOVE:      reasonText = "EA removed from chart"; break;
      case REASON_RECOMPILE:   reasonText = "EA recompiled"; break;
      case REASON_CHARTCHANGE: reasonText = "Symbol or timeframe changed"; break;
      case REASON_CHARTCLOSE:  reasonText = "Chart closed"; break;
      case REASON_PARAMETERS:  reasonText = "Input parameters changed"; break;
      case REASON_ACCOUNT:     reasonText = "Account changed"; break;
      default:                 reasonText = "Unknown reason (" + IntegerToString(reason) + ")"; break;
   }
   Print("EA deinitialized: ", reasonText);
}

`;
}

export function generateOnTick(
  ctx: GeneratorContext,
  tickCode: string[],
  maxIndicatorPeriod: number = 0
): string {
  // Build daily P&L check code if enabled
  let dailyPnlCode = "";
  if (ctx.maxDailyProfitPercent > 0 || ctx.maxDailyLossPercent > 0) {
    dailyPnlCode = `
   //--- Daily P&L Protection
   {
      double dailyPnL = 0;
      datetime todayStart = iTime(Symbol(), PERIOD_D1, 0);

      // Sum closed trades today
      for(int i = OrdersHistoryTotal() - 1; i >= 0; i--)
      {
         if(!OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
         if(OrderMagicNumber() != InpMagicNumber) continue;
         if(OrderSymbol() != Symbol()) continue;
         if(OrderCloseTime() < todayStart) continue;
         if(OrderType() <= OP_SELL)
            dailyPnL += OrderProfit() + OrderSwap() + OrderCommission();
      }

      // Add floating P&L
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
         if(OrderMagicNumber() != InpMagicNumber) continue;
         if(OrderSymbol() != Symbol()) continue;
         if(OrderType() <= OP_SELL)
            dailyPnL += OrderProfit() + OrderSwap();
      }

      double balance = AccountBalance();
      double dailyPnLPercent = (balance > 0) ? (dailyPnL / balance) * 100.0 : 0;

      // Reset daily limit flags on new day
      static datetime lastPnLDay = 0;
      static bool profitLimitHit = false;
      static bool lossLimitHit = false;
      if(todayStart != lastPnLDay)
      {
         lastPnLDay = todayStart;
         profitLimitHit = false;
         lossLimitHit = false;
      }
      if(profitLimitHit || lossLimitHit) return;
`;
    if (ctx.maxDailyProfitPercent > 0) {
      dailyPnlCode += `
      if(dailyPnLPercent >= ${ctx.maxDailyProfitPercent})
      {
         CloseAllPositions();
         Print("Daily profit target reached: ", DoubleToString(dailyPnLPercent, 2), "%");
         profitLimitHit = true;
         return;
      }
`;
    }
    if (ctx.maxDailyLossPercent > 0) {
      dailyPnlCode += `
      if(dailyPnLPercent <= -${ctx.maxDailyLossPercent})
      {
         CloseAllPositions();
         Print("Daily loss limit reached: ", DoubleToString(dailyPnLPercent, 2), "%");
         lossLimitHit = true;
         return;
      }
`;
    }
    dailyPnlCode += "   }\n";
  }

  // Build total drawdown check if enabled
  let totalDrawdownCode = "";
  if (ctx.maxTotalDrawdownPercent > 0) {
    totalDrawdownCode = `
   //--- Total Drawdown Protection
   {
      static double gPeakEquity = 0;
      double equity = AccountEquity();
      if(equity > gPeakEquity) gPeakEquity = equity;
      if(gPeakEquity > 0)
      {
         double dd = (gPeakEquity - equity) / gPeakEquity * 100.0;
         if(dd >= ${ctx.maxTotalDrawdownPercent})
         {
            CloseAllPositions();
            Print("Total drawdown limit reached: ", DoubleToString(dd, 2), "% (max ${ctx.maxTotalDrawdownPercent}%)");
            return;
         }
      }
   }
`;
  }

  // Build equity target check if enabled
  let equityTargetCode = "";
  if (ctx.equityTargetPercent > 0) {
    equityTargetCode = `
   //--- Equity Target
   {
      static double gStartBalance = 0;
      if(gStartBalance == 0) gStartBalance = AccountBalance();
      double equity = AccountEquity();
      double growth = (equity - gStartBalance) / gStartBalance * 100.0;
      if(growth >= ${ctx.equityTargetPercent})
      {
         CloseAllPositions();
         Print("Equity target reached: +", DoubleToString(growth, 2), "% (target ${ctx.equityTargetPercent}%)");
         return;
      }
   }
`;
  }

  // Build cooldown after loss check if enabled
  let cooldownCode = "";
  if (ctx.cooldownAfterLossMinutes > 0) {
    cooldownCode = `
   //--- Cooldown After Loss
   {
      static datetime gLastLossTime = 0;
      for(int d = OrdersHistoryTotal() - 1; d >= 0; d--)
      {
         if(!OrderSelect(d, SELECT_BY_POS, MODE_HISTORY)) continue;
         if(OrderMagicNumber() != InpMagicNumber) continue;
         if(OrderSymbol() != Symbol()) continue;
         if(OrderType() > OP_SELL) continue;
         double dealProfit = OrderProfit() + OrderSwap() + OrderCommission();
         if(dealProfit < 0)
         {
            datetime dealTime = OrderCloseTime();
            if(dealTime > gLastLossTime) gLastLossTime = dealTime;
         }
         break;
      }
      if(gLastLossTime > 0 && TimeCurrent() - gLastLossTime < ${ctx.cooldownAfterLossMinutes} * 60)
         return;
   }
`;
  }

  // Build min bars between trades check if enabled
  let minBarsCode = "";
  if (ctx.minBarsBetweenTrades > 0) {
    minBarsCode = `
   //--- Min Bars Between Trades
   static int gLastTradeBar = 0;
   {
      int currentBar = Bars;
      if(gLastTradeBar > 0 && currentBar - gLastTradeBar < ${ctx.minBarsBetweenTrades})
         return;
   }
`;
  }

  return `//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Check if trading is allowed
   if(!IsTradeAllowed()) return;

   //--- Check for new bar (optional: only trade on new bars)
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(Symbol(), PERIOD_CURRENT, 0);
   bool isNewBar = (currentBarTime != lastBarTime);
   if(isNewBar) lastBarTime = currentBarTime;

   //--- Check minimum bars available
   if(Bars < ${Math.max(maxIndicatorPeriod * 3, 100)})
   {
      static bool barsWarned = false;
      if(!barsWarned) { Print("Waiting for minimum bars (${Math.max(maxIndicatorPeriod * 3, 100)}) on ", Symbol()); barsWarned = true; }
      return;
   }

${totalDrawdownCode}${equityTargetCode}${dailyPnlCode}${cooldownCode}${minBarsCode}
   //--- Count current positions
   int positionsCount = CountPositions();

${tickCode.map((line) => "   " + line).join("\n")}
}

`;
}

export function generateHelperFunctions(ctx: GeneratorContext): string {
  return `//+------------------------------------------------------------------+
//| Count positions for this EA                                        |
//+------------------------------------------------------------------+
int CountPositions()
{
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderMagicNumber() == InpMagicNumber && OrderSymbol() == Symbol() && OrderType() <= OP_SELL)
         count++;
   }
   return count;
}

//+------------------------------------------------------------------+
//| Count positions by type                                            |
//+------------------------------------------------------------------+
int CountPositionsByType(int posType)
{
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderMagicNumber() == InpMagicNumber && OrderSymbol() == Symbol() && OrderType() == posType)
         count++;
   }
   return count;
}

//+------------------------------------------------------------------+
//| Open Buy Position                                                  |
//+------------------------------------------------------------------+
bool OpenBuy(double lots, double sl = 0, double tp = 0)
{
   //--- Pre-trade margin check
   double marginRequired = lots * MarketInfo(Symbol(), MODE_MARGINREQUIRED);
   if(marginRequired > AccountFreeMargin())
   {
      Print("OpenBuy: insufficient margin. Required: ", DoubleToString(marginRequired, 2),
            " Free: ", DoubleToString(AccountFreeMargin(), 2));
      return false;
   }

   int retries = 3;
   for(int attempt = 0; attempt < retries; attempt++)
   {
      RefreshRates();
      double askPrice = Ask;
      double slPrice = (sl > 0) ? NormalizeDouble(askPrice - sl * Point, Digits) : 0;
      double tpPrice = (tp > 0) ? NormalizeDouble(askPrice + tp * Point, Digits) : 0;

      int ticket = OrderSend(Symbol(), OP_BUY, lots, askPrice, InpMaxSlippage, slPrice, tpPrice, InpTradeComment, InpMagicNumber, 0, clrGreen);
      if(ticket > 0) return true;

      int err = GetLastError();
      //--- Retryable errors
      if(err == ERR_REQUOTE || err == ERR_PRICE_CHANGED || err == ERR_OFF_QUOTES)
      {
         Print("OpenBuy retry ", attempt + 1, "/", retries, ": error ", err);
         Sleep(200 * (attempt + 1));
         continue;
      }
      //--- Non-retryable errors
      if(err == ERR_NOT_ENOUGH_MONEY)
         Print("OpenBuy: insufficient funds for ", DoubleToString(lots, 2), " lots");
      else if(err == ERR_INVALID_TRADE_VOLUME)
         Print("OpenBuy: invalid volume ", DoubleToString(lots, 2),
               " (min=", DoubleToString(MarketInfo(Symbol(), MODE_MINLOT), 2),
               " max=", DoubleToString(MarketInfo(Symbol(), MODE_MAXLOT), 2), ")");
      else
         Print("OpenBuy failed: error ", err);
      return false;
   }
   Print("OpenBuy failed after ", retries, " retries");
   return false;
}

//+------------------------------------------------------------------+
//| Open Sell Position                                                 |
//+------------------------------------------------------------------+
bool OpenSell(double lots, double sl = 0, double tp = 0)
{
   //--- Pre-trade margin check
   double marginRequired = lots * MarketInfo(Symbol(), MODE_MARGINREQUIRED);
   if(marginRequired > AccountFreeMargin())
   {
      Print("OpenSell: insufficient margin. Required: ", DoubleToString(marginRequired, 2),
            " Free: ", DoubleToString(AccountFreeMargin(), 2));
      return false;
   }

   int retries = 3;
   for(int attempt = 0; attempt < retries; attempt++)
   {
      RefreshRates();
      double bidPrice = Bid;
      double slPrice = (sl > 0) ? NormalizeDouble(bidPrice + sl * Point, Digits) : 0;
      double tpPrice = (tp > 0) ? NormalizeDouble(bidPrice - tp * Point, Digits) : 0;

      int ticket = OrderSend(Symbol(), OP_SELL, lots, bidPrice, InpMaxSlippage, slPrice, tpPrice, InpTradeComment, InpMagicNumber, 0, clrRed);
      if(ticket > 0) return true;

      int err = GetLastError();
      //--- Retryable errors
      if(err == ERR_REQUOTE || err == ERR_PRICE_CHANGED || err == ERR_OFF_QUOTES)
      {
         Print("OpenSell retry ", attempt + 1, "/", retries, ": error ", err);
         Sleep(200 * (attempt + 1));
         continue;
      }
      //--- Non-retryable errors
      if(err == ERR_NOT_ENOUGH_MONEY)
         Print("OpenSell: insufficient funds for ", DoubleToString(lots, 2), " lots");
      else if(err == ERR_INVALID_TRADE_VOLUME)
         Print("OpenSell: invalid volume ", DoubleToString(lots, 2),
               " (min=", DoubleToString(MarketInfo(Symbol(), MODE_MINLOT), 2),
               " max=", DoubleToString(MarketInfo(Symbol(), MODE_MAXLOT), 2), ")");
      else
         Print("OpenSell failed: error ", err);
      return false;
   }
   Print("OpenSell failed after ", retries, " retries");
   return false;
}

//+------------------------------------------------------------------+
//| Close All Positions                                                |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderMagicNumber() != InpMagicNumber || OrderSymbol() != Symbol()) continue;
      if(OrderType() == OP_BUY)
         OrderClose(OrderTicket(), OrderLots(), Bid, InpMaxSlippage, clrGreen);
      else if(OrderType() == OP_SELL)
         OrderClose(OrderTicket(), OrderLots(), Ask, InpMaxSlippage, clrRed);
      else
         OrderDelete(OrderTicket());
   }
}

//+------------------------------------------------------------------+
//| Close Buy Positions                                                |
//+------------------------------------------------------------------+
void CloseBuyPositions()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderMagicNumber() != InpMagicNumber || OrderSymbol() != Symbol()) continue;
      if(OrderType() == OP_BUY)
         OrderClose(OrderTicket(), OrderLots(), Bid, InpMaxSlippage, clrGreen);
   }
}

//+------------------------------------------------------------------+
//| Close Sell Positions                                               |
//+------------------------------------------------------------------+
void CloseSellPositions()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) continue;
      if(OrderMagicNumber() != InpMagicNumber || OrderSymbol() != Symbol()) continue;
      if(OrderType() == OP_SELL)
         OrderClose(OrderTicket(), OrderLots(), Ask, InpMaxSlippage, clrRed);
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on Risk Percentage                        |
//| Note: slPips parameter is in POINTS (not pips).                    |
//+------------------------------------------------------------------+
double CalculateLotSize(double riskPercent, double slPips)
{
   double minLot = MarketInfo(Symbol(), MODE_MINLOT);
   if(slPips <= 0)
   {
      Print("WARNING: CalculateLotSize called with slPips=0, using minimum lot.");
      return minLot;
   }

   if(minLot <= 0)
   {
      Print("WARNING: MODE_MINLOT is 0 for ", Symbol(), ", defaulting to 0.01");
      minLot = 0.01;
   }

   double balance = InpUseEquityForRisk ? AccountEquity() : AccountBalance();
   if(balance <= 0)
   {
      Print("WARNING: Account balance/equity is 0, using minimum lot.");
      return minLot;
   }

   double tickValue = MarketInfo(Symbol(), MODE_TICKVALUE);
   double tickSize = MarketInfo(Symbol(), MODE_TICKSIZE);
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   double maxLot = MarketInfo(Symbol(), MODE_MAXLOT);

   double pipValue = (tickSize > 0) ? tickValue * (Point / tickSize) : 0;
   if(pipValue <= 0)
   {
      Print("WARNING: Pip value is 0, using minimum lot.");
      return minLot;
   }

   double riskAmount = balance * riskPercent / 100.0;
   double lots = riskAmount / (slPips * pipValue);

   //--- Normalize lot size
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));
   int lotDigits = (int)MathMax(-MathLog10(lotStep), 0);

   return NormalizeDouble(lots, lotDigits);
}

//+------------------------------------------------------------------+
//| Epsilon-safe double comparisons                                    |
//+------------------------------------------------------------------+
bool DoubleGT(double a, double b)  { return (a - b) >  1e-10; }
bool DoubleLT(double a, double b)  { return (b - a) >  1e-10; }
bool DoubleGE(double a, double b)  { return (a - b) > -1e-10; }
bool DoubleLE(double a, double b)  { return (b - a) > -1e-10; }

//+------------------------------------------------------------------+
//| Log message to both Journal and file                              |
//+------------------------------------------------------------------+
void LogToFile(string message)
{
   Print(message);
   static int logHandle = INVALID_HANDLE;
   static string logFileName = "";
   if(logHandle == INVALID_HANDLE)
   {
      logFileName = "EA_" + IntegerToString(InpMagicNumber) + "_" + Symbol() + ".log";
      logHandle = FileOpen(logFileName, FILE_WRITE|FILE_READ|FILE_TXT|FILE_COMMON);
      if(logHandle == INVALID_HANDLE) return;
      FileSeek(logHandle, 0, SEEK_END);
   }
   string timestamp = TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES|TIME_SECONDS);
   FileWriteString(logHandle, timestamp + " | " + message + "\\n");
   FileFlush(logHandle);
}

//+------------------------------------------------------------------+
//| Display strategy overlay on chart (subtle info labels)            |
//+------------------------------------------------------------------+
void ShowStrategyOverlay()
{
   string prefix = "AS_Info_";
   int fontSize = 8;
   color headerClr = C'140,140,160';
   color lineClr   = C'100,100,120';
   int x = 12;
   int y = 24;
   int lineH = 14;
   int row = 0;

   CreateOverlayLabel(prefix + "0", x, y, InpStrategyDescription, "Consolas", fontSize + 1, headerClr);
   row++;

   for(int i = 0; i < ArraySize(g_strategyInfo); i++)
   {
      CreateOverlayLabel(prefix + IntegerToString(row), x, y + row * lineH, g_strategyInfo[i], "Consolas", fontSize, lineClr);
      row++;
   }

   string footer = "Magic: " + IntegerToString(InpMagicNumber) + "  |  " + Symbol() + " " + EnumToString((ENUM_TIMEFRAMES)Period());
   CreateOverlayLabel(prefix + IntegerToString(row), x, y + row * lineH, footer, "Consolas", fontSize, lineClr);
}

void CreateOverlayLabel(string name, int xDist, int yDist, string text, string font, int size, color clr)
{
   if(ObjectFind(name) < 0)
      ObjectCreate(name, OBJ_LABEL, 0, 0, 0);
   ObjectSet(name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSet(name, OBJPROP_XDISTANCE, xDist);
   ObjectSet(name, OBJPROP_YDISTANCE, yDist);
   ObjectSetText(name, text, size, font, clr);
}

`;
}
