/**
 * Report Manifest — cryptographic signing and verification for investor-proof reports.
 *
 * Uses Ed25519 signatures:
 * - Fast (< 1ms per sign/verify)
 * - Small keys (32 bytes) and signatures (64 bytes)
 * - Deterministic (same key + message → same signature)
 * - No configuration needed (no curve parameters, no padding)
 *
 * Key management:
 * - Private key stored in TRACK_RECORD_SIGNING_KEY env var (hex-encoded)
 * - If not present, generates an ephemeral key pair (suitable for dev/demo)
 * - Public key included in every manifest for self-contained verification
 *
 * The manifest is the root of trust: it contains the reportBodyHash which
 * is the SHA-256 of the canonical report body JSON. A valid signature proves
 * the report was generated by the holder of the signing key.
 */

import { sign, verify, createPrivateKey, createPublicKey } from "crypto";
import type { ReportManifest, ReportBody } from "./types";
import { sha256 } from "./canonical";

// ============================================
// KEY MANAGEMENT
// ============================================

interface KeyPair {
  privateKey: string; // hex-encoded raw private key
  publicKey: string; // hex-encoded raw public key
  /** First 16 hex chars of SHA-256(publicKey). Identifies which key signed a report. */
  version: string;
}

let cachedKeyPair: KeyPair | null = null;
let cachedPreviousPublicKey: { publicKey: string; version: string } | null = null;

/**
 * Compute key version fingerprint: first 16 hex chars of SHA-256(publicKeyHex).
 */
export function keyFingerprint(publicKeyHex: string): string {
  return sha256(publicKeyHex).slice(0, 16);
}

/**
 * Derive a KeyPair from a hex-encoded Ed25519 private key.
 */
function deriveKeyPair(privateKeyHex: string): KeyPair {
  const privKeyBuf = Buffer.from(privateKeyHex, "hex");
  const keyObj = {
    key: Buffer.concat([
      Buffer.from("302e020100300506032b657004220420", "hex"), // Ed25519 PKCS8 prefix
      privKeyBuf.subarray(0, 32),
    ]),
    format: "der" as const,
    type: "pkcs8" as const,
  };
  const privKeyObj = createPrivateKey(keyObj);
  const pubKeyObj = createPublicKey(privKeyObj);
  const pubKeyDer = pubKeyObj.export({ type: "spki", format: "der" });
  const pubKeyRaw = pubKeyDer.subarray(pubKeyDer.length - 32);
  const publicKey = pubKeyRaw.toString("hex");

  return {
    privateKey: privateKeyHex.slice(0, 64),
    publicKey,
    version: keyFingerprint(publicKey),
  };
}

/**
 * Get the current signing key pair. Uses TRACK_RECORD_SIGNING_KEY env var.
 */
export function getSigningKeyPair(): KeyPair {
  if (cachedKeyPair) return cachedKeyPair;

  const envKey = process.env.TRACK_RECORD_SIGNING_KEY;
  if (envKey && envKey.length >= 64) {
    cachedKeyPair = deriveKeyPair(envKey);
    return cachedKeyPair;
  }

  throw new Error(
    "TRACK_RECORD_SIGNING_KEY environment variable is required. " +
      "Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\""
  );
}

/**
 * Get the previous signing key's public key (for verifying reports signed before rotation).
 * Uses TRACK_RECORD_SIGNING_KEY_PREVIOUS env var.
 */
export function getPreviousPublicKey(): { publicKey: string; version: string } | null {
  if (cachedPreviousPublicKey !== undefined && cachedPreviousPublicKey !== null) {
    return cachedPreviousPublicKey;
  }

  const prevKey = process.env.TRACK_RECORD_SIGNING_KEY_PREVIOUS;
  if (prevKey && prevKey.length >= 64) {
    const kp = deriveKeyPair(prevKey);
    cachedPreviousPublicKey = { publicKey: kp.publicKey, version: kp.version };
    return cachedPreviousPublicKey;
  }

  cachedPreviousPublicKey = null;
  return null;
}

/**
 * Get all trusted public keys (current + previous) for verification.
 * Used by the well-known endpoint and the verifier.
 */
export function getTrustedPublicKeys(): {
  publicKey: string;
  version: string;
  status: "current" | "previous";
}[] {
  const keys: { publicKey: string; version: string; status: "current" | "previous" }[] = [];

  try {
    const current = getSigningKeyPair();
    keys.push({ publicKey: current.publicKey, version: current.version, status: "current" });
  } catch {
    // No current key configured
  }

  const prev = getPreviousPublicKey();
  if (prev) {
    keys.push({ publicKey: prev.publicKey, version: prev.version, status: "previous" });
  }

  return keys;
}

// ============================================
// CANONICAL REPORT BODY SERIALIZATION
// ============================================

/**
 * Serialize the report body to a canonical JSON string.
 * - Keys sorted alphabetically at every level
 * - No whitespace
 * - Numbers as-is (already formatted as strings in ReportBody)
 */
export function canonicalizeReportBody(body: ReportBody): string {
  return stableStringify(body);
}

/**
 * Deterministic JSON stringification with sorted keys at every level.
 */
function stableStringify(obj: unknown): string {
  if (obj === null || obj === undefined) return "null";
  if (typeof obj === "string") return JSON.stringify(obj);
  if (typeof obj === "number" || typeof obj === "boolean") return String(obj);
  if (Array.isArray(obj)) {
    return "[" + obj.map(stableStringify).join(",") + "]";
  }
  if (typeof obj === "object") {
    const keys = Object.keys(obj as Record<string, unknown>).sort();
    const pairs = keys
      .filter((k) => (obj as Record<string, unknown>)[k] !== undefined)
      .map((k) => JSON.stringify(k) + ":" + stableStringify((obj as Record<string, unknown>)[k]));
    return "{" + pairs.join(",") + "}";
  }
  return String(obj);
}

// ============================================
// SIGNING & VERIFICATION
// ============================================

/**
 * Sign a report body hash using Ed25519.
 * Returns the hex-encoded signature.
 */
export function signReportHash(reportBodyHash: string): {
  signature: string;
  publicKey: string;
  signingKeyVersion: string;
} {
  const keyPair = getSigningKeyPair();

  // Build Ed25519 private key in PKCS8 DER format
  const privKeyDer = Buffer.concat([
    Buffer.from("302e020100300506032b657004220420", "hex"),
    Buffer.from(keyPair.privateKey, "hex"),
  ]);

  const privateKeyObj = createPrivateKey({
    key: privKeyDer,
    format: "der",
    type: "pkcs8",
  });

  const hashBuf = Buffer.from(reportBodyHash, "utf8");
  const sig = sign(null, hashBuf, privateKeyObj);

  return {
    signature: sig.toString("hex"),
    publicKey: keyPair.publicKey,
    signingKeyVersion: keyPair.version,
  };
}

/**
 * Verify a report signature. Returns true if valid.
 * This is a standalone function — any third party can verify with just
 * the publicKey, reportBodyHash, and signature.
 */
export function verifyReportSignature(
  reportBodyHash: string,
  signatureHex: string,
  publicKeyHex: string
): boolean {
  try {
    // Build Ed25519 public key in SPKI DER format
    const pubKeyDer = Buffer.concat([
      Buffer.from("302a300506032b6570032100", "hex"),
      Buffer.from(publicKeyHex, "hex"),
    ]);

    const publicKeyObj = createPublicKey({
      key: pubKeyDer,
      format: "der",
      type: "spki",
    });

    const hashBuf = Buffer.from(reportBodyHash, "utf8");
    const sigBuf = Buffer.from(signatureHex, "hex");

    return verify(null, hashBuf, publicKeyObj, sigBuf);
  } catch {
    return false;
  }
}

/**
 * Compute the ledger root hash using a Merkle tree.
 * This binds the report to the exact event sequence and enables
 * partial verification — a verifier can check a subset of events
 * using a Merkle proof without replaying the entire chain.
 *
 * Tree structure:
 * - Leaves = SHA-256 of each event hash (double-hashed for domain separation)
 * - Internal nodes = SHA-256(left || right)
 * - Odd leaves: last leaf is promoted (not duplicated, to prevent second-preimage)
 */
export function computeLedgerRootHash(eventHashes: string[]): string {
  if (eventHashes.length === 0) return sha256("");
  if (eventHashes.length === 1) return sha256(eventHashes[0]);

  // Build leaf nodes: double-hash for domain separation from internal nodes
  let level = eventHashes.map((h) => sha256("leaf:" + h));

  while (level.length > 1) {
    const next: string[] = [];
    for (let i = 0; i < level.length; i += 2) {
      if (i + 1 < level.length) {
        next.push(sha256(level[i] + level[i + 1]));
      } else {
        // Odd node: promote without duplication (prevents second-preimage attacks)
        next.push(level[i]);
      }
    }
    level = next;
  }

  return level[0];
}

/**
 * Generate a Merkle proof for a specific event index.
 * Returns sibling hashes + directions needed to reconstruct the root.
 */
export function generateMerkleProof(
  eventHashes: string[],
  index: number
): { siblings: string[]; directions: ("L" | "R")[] } {
  if (index < 0 || index >= eventHashes.length) {
    return { siblings: [], directions: [] };
  }

  const siblings: string[] = [];
  const directions: ("L" | "R")[] = [];

  let level = eventHashes.map((h) => sha256("leaf:" + h));
  let pos = index;

  while (level.length > 1) {
    const next: string[] = [];
    for (let i = 0; i < level.length; i += 2) {
      if (i + 1 < level.length) {
        if (i === pos || i + 1 === pos) {
          if (pos % 2 === 0) {
            siblings.push(level[i + 1]);
            directions.push("R");
          } else {
            siblings.push(level[i]);
            directions.push("L");
          }
        }
        next.push(sha256(level[i] + level[i + 1]));
      } else {
        next.push(level[i]);
      }
    }
    level = next;
    pos = Math.floor(pos / 2);
  }

  return { siblings, directions };
}

/**
 * Verify a Merkle proof for a single event hash against the root.
 */
export function verifyMerkleProof(
  eventHash: string,
  proof: { siblings: string[]; directions: ("L" | "R")[] },
  expectedRoot: string
): boolean {
  let current = sha256("leaf:" + eventHash);

  for (let i = 0; i < proof.siblings.length; i++) {
    if (proof.directions[i] === "R") {
      current = sha256(current + proof.siblings[i]);
    } else {
      current = sha256(proof.siblings[i] + current);
    }
  }

  return current === expectedRoot;
}

/**
 * Build a complete report manifest.
 */
export function buildManifest(
  reportId: string,
  instanceId: string,
  fromSeqNo: number,
  toSeqNo: number,
  fromTimestamp: string,
  toTimestamp: string,
  firstEventHash: string,
  lastEventHash: string,
  eventHashes: string[],
  reportBody: ReportBody
): ReportManifest {
  const canonicalBody = canonicalizeReportBody(reportBody);
  const reportBodyHash = sha256(canonicalBody);
  const ledgerRootHash = computeLedgerRootHash(eventHashes);
  const { signature, publicKey, signingKeyVersion } = signReportHash(reportBodyHash);

  return {
    schemaVersion: "2.0",
    reportId,
    instanceId,
    calculationVersion: "algostudio-v2.0.0",
    fromSeqNo,
    toSeqNo,
    fromTimestamp,
    toTimestamp,
    equityPolicy: "BALANCE_PLUS_UNREALIZED",
    cashflowPolicy: "ADJUST_HWM_NO_DD_RESET",
    firstEventHash,
    lastEventHash,
    ledgerRootHash,
    reportBodyHash,
    signature,
    publicKey,
    signingKeyVersion,
    generatedAt: new Date().toISOString(),
  };
}
