/**
 * Report Manifest — cryptographic signing and verification for investor-proof reports.
 *
 * Uses Ed25519 signatures:
 * - Fast (< 1ms per sign/verify)
 * - Small keys (32 bytes) and signatures (64 bytes)
 * - Deterministic (same key + message → same signature)
 * - No configuration needed (no curve parameters, no padding)
 *
 * Key management:
 * - Private key stored in TRACK_RECORD_SIGNING_KEY env var (hex-encoded)
 * - If not present, generates an ephemeral key pair (suitable for dev/demo)
 * - Public key included in every manifest for self-contained verification
 *
 * The manifest is the root of trust: it contains the reportBodyHash which
 * is the SHA-256 of the canonical report body JSON. A valid signature proves
 * the report was generated by the holder of the signing key.
 */

import { sign, verify, createPrivateKey, createPublicKey } from "crypto";
import type { ReportManifest, ReportBody } from "./types";
import { sha256 } from "./canonical";

// ============================================
// KEY MANAGEMENT
// ============================================

interface KeyPair {
  privateKey: string; // hex-encoded raw private key
  publicKey: string; // hex-encoded raw public key
}

let cachedKeyPair: KeyPair | null = null;

/**
 * Get the signing key pair. Uses TRACK_RECORD_SIGNING_KEY env var if available,
 * otherwise generates an ephemeral pair (logged as warning).
 */
export function getSigningKeyPair(): KeyPair {
  if (cachedKeyPair) return cachedKeyPair;

  const envKey = process.env.TRACK_RECORD_SIGNING_KEY;
  if (envKey && envKey.length >= 64) {
    // Derive public key from private key
    const privKeyBuf = Buffer.from(envKey, "hex");
    const keyObj = {
      key: Buffer.concat([
        Buffer.from("302e020100300506032b657004220420", "hex"), // Ed25519 PKCS8 prefix
        privKeyBuf.subarray(0, 32),
      ]),
      format: "der" as const,
      type: "pkcs8" as const,
    };
    const privKeyObj = createPrivateKey(keyObj);
    const pubKeyObj = createPublicKey(privKeyObj);
    const pubKeyDer = pubKeyObj.export({ type: "spki", format: "der" });
    const pubKeyRaw = pubKeyDer.subarray(pubKeyDer.length - 32);

    cachedKeyPair = {
      privateKey: envKey.slice(0, 64),
      publicKey: pubKeyRaw.toString("hex"),
    };
    return cachedKeyPair;
  }

  throw new Error(
    "TRACK_RECORD_SIGNING_KEY environment variable is required. " +
      "Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\""
  );
}

// ============================================
// CANONICAL REPORT BODY SERIALIZATION
// ============================================

/**
 * Serialize the report body to a canonical JSON string.
 * - Keys sorted alphabetically at every level
 * - No whitespace
 * - Numbers as-is (already formatted as strings in ReportBody)
 */
export function canonicalizeReportBody(body: ReportBody): string {
  return stableStringify(body);
}

/**
 * Deterministic JSON stringification with sorted keys at every level.
 */
function stableStringify(obj: unknown): string {
  if (obj === null || obj === undefined) return "null";
  if (typeof obj === "string") return JSON.stringify(obj);
  if (typeof obj === "number" || typeof obj === "boolean") return String(obj);
  if (Array.isArray(obj)) {
    return "[" + obj.map(stableStringify).join(",") + "]";
  }
  if (typeof obj === "object") {
    const keys = Object.keys(obj as Record<string, unknown>).sort();
    const pairs = keys
      .filter((k) => (obj as Record<string, unknown>)[k] !== undefined)
      .map((k) => JSON.stringify(k) + ":" + stableStringify((obj as Record<string, unknown>)[k]));
    return "{" + pairs.join(",") + "}";
  }
  return String(obj);
}

// ============================================
// SIGNING & VERIFICATION
// ============================================

/**
 * Sign a report body hash using Ed25519.
 * Returns the hex-encoded signature.
 */
export function signReportHash(reportBodyHash: string): {
  signature: string;
  publicKey: string;
} {
  const keyPair = getSigningKeyPair();

  // Build Ed25519 private key in PKCS8 DER format
  const privKeyDer = Buffer.concat([
    Buffer.from("302e020100300506032b657004220420", "hex"),
    Buffer.from(keyPair.privateKey, "hex"),
  ]);

  const privateKeyObj = createPrivateKey({
    key: privKeyDer,
    format: "der",
    type: "pkcs8",
  });

  const hashBuf = Buffer.from(reportBodyHash, "utf8");
  const sig = sign(null, hashBuf, privateKeyObj);

  return {
    signature: sig.toString("hex"),
    publicKey: keyPair.publicKey,
  };
}

/**
 * Verify a report signature. Returns true if valid.
 * This is a standalone function — any third party can verify with just
 * the publicKey, reportBodyHash, and signature.
 */
export function verifyReportSignature(
  reportBodyHash: string,
  signatureHex: string,
  publicKeyHex: string
): boolean {
  try {
    // Build Ed25519 public key in SPKI DER format
    const pubKeyDer = Buffer.concat([
      Buffer.from("302a300506032b6570032100", "hex"),
      Buffer.from(publicKeyHex, "hex"),
    ]);

    const publicKeyObj = createPublicKey({
      key: pubKeyDer,
      format: "der",
      type: "spki",
    });

    const hashBuf = Buffer.from(reportBodyHash, "utf8");
    const sigBuf = Buffer.from(signatureHex, "hex");

    return verify(null, hashBuf, publicKeyObj, sigBuf);
  } catch {
    return false;
  }
}

/**
 * Compute the ledger root hash: SHA-256(concat(all event hashes in range)).
 * This binds the report to the exact event sequence.
 */
export function computeLedgerRootHash(eventHashes: string[]): string {
  const concatenated = eventHashes.join("");
  return sha256(concatenated);
}

/**
 * Build a complete report manifest.
 */
export function buildManifest(
  reportId: string,
  instanceId: string,
  fromSeqNo: number,
  toSeqNo: number,
  fromTimestamp: string,
  toTimestamp: string,
  firstEventHash: string,
  lastEventHash: string,
  eventHashes: string[],
  reportBody: ReportBody
): ReportManifest {
  const canonicalBody = canonicalizeReportBody(reportBody);
  const reportBodyHash = sha256(canonicalBody);
  const ledgerRootHash = computeLedgerRootHash(eventHashes);
  const { signature, publicKey } = signReportHash(reportBodyHash);

  return {
    schemaVersion: "2.0",
    reportId,
    instanceId,
    calculationVersion: "algostudio-v2.0.0",
    fromSeqNo,
    toSeqNo,
    fromTimestamp,
    toTimestamp,
    equityPolicy: "BALANCE_PLUS_UNREALIZED",
    cashflowPolicy: "ADJUST_HWM_NO_DD_RESET",
    firstEventHash,
    lastEventHash,
    ledgerRootHash,
    reportBodyHash,
    signature,
    publicKey,
    generatedAt: new Date().toISOString(),
  };
}
