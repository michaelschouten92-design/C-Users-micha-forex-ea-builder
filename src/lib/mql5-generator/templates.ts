// MQL5 Code Templates

import type { GeneratorContext, OptimizableInput } from "./types";

export function generateFileHeader(ctx: GeneratorContext): string {
  const timestamp = new Date().toISOString();
  return `//+------------------------------------------------------------------+
//|                                    ${ctx.projectName.padEnd(36)}|
//|                                    Generated by AlgoStudio        |
//|                                    ${timestamp.substring(0, 19).padEnd(36)}|
//+------------------------------------------------------------------+
#property copyright "AlgoStudio"
#property link      "https://algostudio.app"
#property version   "1.00"
#property strict

`;
}

export function generateTradeIncludes(): string {
  return `//--- Include trade library
#include <Trade\\Trade.mqh>

//--- Trade object
CTrade trade;

`;
}

export function generateInputsSection(inputs: OptimizableInput[]): string {
  if (inputs.length === 0) return "";

  const lines = inputs.map((input) => {
    if (input.isOptimizable) {
      return `input ${input.type} ${input.name} = ${input.value}; // ${input.comment}`;
    } else {
      return `const ${input.type} ${input.name} = ${input.value}; // ${input.comment} (fixed)`;
    }
  });

  return `//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
${lines.join("\n")}

`;
}

export function generateGlobalVariablesSection(variables: string[]): string {
  if (variables.length === 0) return "";

  return `//+------------------------------------------------------------------+
//| Global Variables                                                   |
//+------------------------------------------------------------------+
${variables.join("\n")}

`;
}

export function generateOnInit(ctx: GeneratorContext, initCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Set magic number for trade operations
   trade.SetExpertMagicNumber(${ctx.magicNumber});

   //--- Set allowed slippage
   trade.SetDeviationInPoints(10);

   //--- Set trade comment
   trade.SetTypeFillingBySymbol(_Symbol);

${initCode.map(line => "   " + line).join("\n")}

   return(INIT_SUCCEEDED);
}

`;
}

export function generateOnDeinit(deinitCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
${deinitCode.length > 0 ? deinitCode.map(line => "   " + line).join("\n") : "   //--- Cleanup"}
}

`;
}

export function generateOnTick(ctx: GeneratorContext, tickCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Check if trading is allowed
   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) return;
   if(!MQLInfoInteger(MQL_TRADE_ALLOWED)) return;

   //--- Check for new bar (optional: only trade on new bars)
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
   bool isNewBar = (currentBarTime != lastBarTime);
   if(isNewBar) lastBarTime = currentBarTime;

   //--- Count current positions
   int positionsCount = CountPositions();

${tickCode.map(line => "   " + line).join("\n")}
}

`;
}

export function generateHelperFunctions(ctx: GeneratorContext): string {
  return `//+------------------------------------------------------------------+
//| Count positions for this EA                                        |
//+------------------------------------------------------------------+
int CountPositions()
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == ${ctx.magicNumber} &&
            PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Count positions by type                                            |
//+------------------------------------------------------------------+
int CountPositionsByType(ENUM_POSITION_TYPE posType)
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == ${ctx.magicNumber} &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == posType)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Open Buy Position                                                  |
//+------------------------------------------------------------------+
bool OpenBuy(double lots, double sl = 0, double tp = 0)
{
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double slPrice = (sl > 0) ? NormalizeDouble(ask - sl * _Point, _Digits) : 0;
   double tpPrice = (tp > 0) ? NormalizeDouble(ask + tp * _Point, _Digits) : 0;

   return trade.Buy(lots, _Symbol, ask, slPrice, tpPrice, "${ctx.comment}");
}

//+------------------------------------------------------------------+
//| Open Sell Position                                                 |
//+------------------------------------------------------------------+
bool OpenSell(double lots, double sl = 0, double tp = 0)
{
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double slPrice = (sl > 0) ? NormalizeDouble(bid + sl * _Point, _Digits) : 0;
   double tpPrice = (tp > 0) ? NormalizeDouble(bid - tp * _Point, _Digits) : 0;

   return trade.Sell(lots, _Symbol, bid, slPrice, tpPrice, "${ctx.comment}");
}

//+------------------------------------------------------------------+
//| Close All Positions                                                |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == ${ctx.magicNumber} &&
            PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close Buy Positions                                                |
//+------------------------------------------------------------------+
void CloseBuyPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == ${ctx.magicNumber} &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close Sell Positions                                               |
//+------------------------------------------------------------------+
void CloseSellPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == ${ctx.magicNumber} &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on Risk Percentage                        |
//+------------------------------------------------------------------+
double CalculateLotSize(double riskPercent, double slPips)
{
   if(slPips <= 0) return SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * riskPercent / 100.0;
   double pipValue = tickValue * (_Point / tickSize);
   double lots = riskAmount / (slPips * pipValue);

   //--- Normalize lot size
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));

   return NormalizeDouble(lots, 2);
}

`;
}
