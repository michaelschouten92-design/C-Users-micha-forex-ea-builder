// MQL5 Code Templates

import type { GeneratorContext, OptimizableInput } from "./types";
import { sanitizeMQL5String } from "./generators/shared";

export function generateFileHeader(ctx: GeneratorContext): string {
  const timestamp = new Date().toISOString();
  const desc = ctx.description ? sanitizeMQL5String(ctx.description) : "";
  // MQL5 #property description lines (max 511 chars each, split on newlines)
  const descLines = desc
    ? desc
        .split(/\\n|\n/)
        .filter((l: string) => l.trim())
        .map((l: string) => `#property description "${l.substring(0, 511)}"`)
        .join("\n")
    : `#property description "${ctx.projectName} â€” Generated by AlgoStudio"`;
  return `//+------------------------------------------------------------------+
//|                                    ${ctx.projectName.padEnd(36)}|
//|                                    Generated by AlgoStudio        |
//|                                    ${timestamp.substring(0, 19).padEnd(36)}|
//+------------------------------------------------------------------+
#property copyright "AlgoStudio"
#property link      "https://algo-studio.com"
#property version   "1.00"
#property strict
${descLines}

`;
}

export function generateTradeIncludes(): string {
  return `//--- Include trade library
#include <Trade\\Trade.mqh>

//--- Trade object
CTrade trade;

`;
}

export function generateInputsSection(inputs: OptimizableInput[]): string {
  if (inputs.length === 0) return "";

  const lines: string[] = [];
  let currentGroup = "";

  for (const input of inputs) {
    // Add group header when group changes
    if (input.group && input.group !== currentGroup) {
      currentGroup = input.group;
      if (lines.length > 0) lines.push("");
      lines.push(`//--- ${currentGroup}`);
    }

    if (input.isOptimizable) {
      lines.push(`input ${input.type} ${input.name} = ${input.value}; // ${input.comment}`);
    } else {
      lines.push(`const ${input.type} ${input.name} = ${input.value}; // ${input.comment} (fixed)`);
    }
  }

  return `//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
${lines.join("\n")}

`;
}

export function generateGlobalVariablesSection(variables: string[]): string {
  if (variables.length === 0) return "";

  return `//+------------------------------------------------------------------+
//| Global Variables                                                   |
//+------------------------------------------------------------------+
${variables.join("\n")}

`;
}

export function generateOnInit(ctx: GeneratorContext, initCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Validate symbol is tradeable
   if(!SymbolInfoInteger(_Symbol, SYMBOL_TRADE_MODE))
   {
      Print("Symbol ", _Symbol, " is not available for trading");
      return(INIT_FAILED);
   }

   //--- Set magic number for trade operations
   trade.SetExpertMagicNumber(InpMagicNumber);

   //--- Set allowed slippage
   trade.SetDeviationInPoints(InpMaxSlippage);

   //--- Set trade fill type
   trade.SetTypeFillingBySymbol(_Symbol);

${initCode.map((line) => "   " + line).join("\n")}

   //--- Display strategy info on chart
   Comment(InpStrategyDescription, "\\n",
           "Magic: ", InpMagicNumber, "  |  ", _Symbol, " ", EnumToString(Period()));

   Print("${ctx.projectName} initialized successfully on ", _Symbol, " ", EnumToString(Period()));
   return(INIT_SUCCEEDED);
}

`;
}

export function generateOnDeinit(deinitCode: string[]): string {
  return `//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //--- Release indicator handles
${deinitCode.length > 0 ? deinitCode.map((line) => "   " + line).join("\n") : "   //--- No handles to release"}

   //--- Clear chart comment
   Comment("");

   //--- Log deinitialization reason
   string reasonText;
   switch(reason)
   {
      case REASON_PROGRAM:     reasonText = "EA stopped by user"; break;
      case REASON_REMOVE:      reasonText = "EA removed from chart"; break;
      case REASON_RECOMPILE:   reasonText = "EA recompiled"; break;
      case REASON_CHARTCHANGE: reasonText = "Symbol or timeframe changed"; break;
      case REASON_CHARTCLOSE:  reasonText = "Chart closed"; break;
      case REASON_PARAMETERS:  reasonText = "Input parameters changed"; break;
      case REASON_ACCOUNT:     reasonText = "Account changed"; break;
      case REASON_TEMPLATE:    reasonText = "Template applied"; break;
      default:                 reasonText = "Unknown reason (" + IntegerToString(reason) + ")"; break;
   }
   Print("EA deinitialized: ", reasonText);
}

`;
}

export function generateOnTick(
  ctx: GeneratorContext,
  tickCode: string[],
  maxIndicatorPeriod: number = 0
): string {
  // Build daily P&L check code if enabled
  let dailyPnlCode = "";
  if (ctx.maxDailyProfitPercent > 0 || ctx.maxDailyLossPercent > 0) {
    dailyPnlCode = `
   //--- Daily P&L Protection
   {
      double dailyPnL = 0;
      datetime todayStart = iTime(_Symbol, PERIOD_D1, 0);

      // Sum closed trades today
      HistorySelect(todayStart, TimeCurrent());
      for(int i = HistoryDealsTotal() - 1; i >= 0; i--)
      {
         ulong dealTicket = HistoryDealGetTicket(i);
         if(dealTicket > 0 && HistoryDealGetInteger(dealTicket, DEAL_MAGIC) == InpMagicNumber)
         {
            dailyPnL += HistoryDealGetDouble(dealTicket, DEAL_PROFIT)
                      + HistoryDealGetDouble(dealTicket, DEAL_SWAP)
                      + HistoryDealGetDouble(dealTicket, DEAL_COMMISSION);
         }
      }

      // Add floating P&L
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0 && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber)
            dailyPnL += PositionGetDouble(POSITION_PROFIT) + PositionGetDouble(POSITION_SWAP);
      }

      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      double dailyPnLPercent = (balance > 0) ? (dailyPnL / balance) * 100.0 : 0;
`;
    if (ctx.maxDailyProfitPercent > 0) {
      dailyPnlCode += `
      if(dailyPnLPercent >= ${ctx.maxDailyProfitPercent})
      {
         CloseAllPositions();
         static bool profitLimitHit = false;
         if(!profitLimitHit) { Print("Daily profit target reached: ", DoubleToString(dailyPnLPercent, 2), "%"); profitLimitHit = true; }
         if(iTime(_Symbol, PERIOD_D1, 0) != todayStart) profitLimitHit = false;
         return;
      }
`;
    }
    if (ctx.maxDailyLossPercent > 0) {
      dailyPnlCode += `
      if(dailyPnLPercent <= -${ctx.maxDailyLossPercent})
      {
         CloseAllPositions();
         static bool lossLimitHit = false;
         if(!lossLimitHit) { Print("Daily loss limit reached: ", DoubleToString(dailyPnLPercent, 2), "%"); lossLimitHit = true; }
         if(iTime(_Symbol, PERIOD_D1, 0) != todayStart) lossLimitHit = false;
         return;
      }
`;
    }
    dailyPnlCode += "   }\n";
  }

  return `//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Check if trading is allowed
   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) return;
   if(!MQLInfoInteger(MQL_TRADE_ALLOWED)) return;

   //--- Check for new bar (optional: only trade on new bars)
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
   bool isNewBar = (currentBarTime != lastBarTime);
   if(isNewBar) lastBarTime = currentBarTime;

   //--- Check minimum bars available
   if(Bars(_Symbol, PERIOD_CURRENT) < ${Math.max(maxIndicatorPeriod * 3, 100)})
   {
      static bool barsWarned = false;
      if(!barsWarned) { Print("Waiting for minimum bars (${Math.max(maxIndicatorPeriod * 3, 100)}) on ", _Symbol); barsWarned = true; }
      return;
   }

${dailyPnlCode}
   //--- Count current positions
   int positionsCount = CountPositions();

${tickCode.map((line) => "   " + line).join("\n")}
}

`;
}

export function generateHelperFunctions(ctx: GeneratorContext): string {
  return `//+------------------------------------------------------------------+
//| Count positions for this EA                                        |
//+------------------------------------------------------------------+
int CountPositions()
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Count positions by type                                            |
//+------------------------------------------------------------------+
int CountPositionsByType(ENUM_POSITION_TYPE posType)
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == posType)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Open Buy Position                                                  |
//+------------------------------------------------------------------+
bool OpenBuy(double lots, double sl = 0, double tp = 0)
{
   int retries = 3;
   for(int attempt = 0; attempt < retries; attempt++)
   {
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double slPrice = (sl > 0) ? NormalizeDouble(ask - sl * _Point, _Digits) : 0;
      double tpPrice = (tp > 0) ? NormalizeDouble(ask + tp * _Point, _Digits) : 0;

      if(trade.Buy(lots, _Symbol, ask, slPrice, tpPrice, "${sanitizeMQL5String(ctx.comment)}"))
         return true;

      uint resultCode = trade.ResultRetcode();
      if(resultCode != TRADE_RETCODE_REQUOTE && resultCode != TRADE_RETCODE_PRICE_OFF)
      {
         Print("OpenBuy failed: ", trade.ResultRetcodeDescription(), " (code: ", resultCode, ")");
         return false;
      }
      Print("OpenBuy requote/price-off, retry ", attempt + 1, "/", retries);
      Sleep(100);
   }
   Print("OpenBuy failed after ", retries, " retries");
   return false;
}

//+------------------------------------------------------------------+
//| Open Sell Position                                                 |
//+------------------------------------------------------------------+
bool OpenSell(double lots, double sl = 0, double tp = 0)
{
   int retries = 3;
   for(int attempt = 0; attempt < retries; attempt++)
   {
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double slPrice = (sl > 0) ? NormalizeDouble(bid + sl * _Point, _Digits) : 0;
      double tpPrice = (tp > 0) ? NormalizeDouble(bid - tp * _Point, _Digits) : 0;

      if(trade.Sell(lots, _Symbol, bid, slPrice, tpPrice, "${sanitizeMQL5String(ctx.comment)}"))
         return true;

      uint resultCode = trade.ResultRetcode();
      if(resultCode != TRADE_RETCODE_REQUOTE && resultCode != TRADE_RETCODE_PRICE_OFF)
      {
         Print("OpenSell failed: ", trade.ResultRetcodeDescription(), " (code: ", resultCode, ")");
         return false;
      }
      Print("OpenSell requote/price-off, retry ", attempt + 1, "/", retries);
      Sleep(100);
   }
   Print("OpenSell failed after ", retries, " retries");
   return false;
}

//+------------------------------------------------------------------+
//| Close All Positions                                                |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close Buy Positions                                                |
//+------------------------------------------------------------------+
void CloseBuyPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Close Sell Positions                                               |
//+------------------------------------------------------------------+
void CloseSellPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Lot Size based on Risk Percentage                        |
//+------------------------------------------------------------------+
double CalculateLotSize(double riskPercent, double slPips)
{
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   if(slPips <= 0) return minLot;

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(balance <= 0) return minLot;

   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   double pipValue = (tickSize > 0) ? tickValue * (_Point / tickSize) : 0;
   if(pipValue <= 0) return minLot;

   double riskAmount = balance * riskPercent / 100.0;
   double lots = riskAmount / (slPips * pipValue);

   //--- Normalize lot size
   lots = MathFloor(lots / lotStep) * lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));

   return NormalizeDouble(lots, 2);
}

//+------------------------------------------------------------------+
//| Epsilon-safe double comparisons                                    |
//+------------------------------------------------------------------+
bool DoubleGT(double a, double b)  { return (a - b) >  1e-10; }
bool DoubleLT(double a, double b)  { return (b - a) >  1e-10; }
bool DoubleGE(double a, double b)  { return (a - b) > -1e-10; }
bool DoubleLE(double a, double b)  { return (b - a) > -1e-10; }

`;
}
